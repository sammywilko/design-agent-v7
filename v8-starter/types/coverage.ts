// types/coverage.ts
// Type definitions for Coverage Generation system (Stage 2.5)

import { CharacterProfile, LocationProfile, ProductProfile } from '../../types';

// Entity union type for coverage
export type CoverableEntity = CharacterProfile | LocationProfile | ProductProfile;
export type EntityType = 'character' | 'product' | 'location';

/**
 * Coverage Library - Complete angle library for an entity
 */
export interface CoverageLibrary {
  id: string;
  entityId: string;
  entityType: EntityType;
  entityName: string;

  packId: string;
  packName: string;

  angles: CoverageAngle[];

  status: 'pending' | 'generating' | 'complete' | 'failed';
  progress: number; // 0-100

  uploadedAngles: number;     // Angles from uploaded photos
  generatedAngles: number;    // Angles generated by AI
  failedAngles: number;       // Failed generations

  createdAt: Date;
  completedAt?: Date;

  metadata?: {
    totalTime?: number;        // Generation time in seconds
    averageTimePerAngle?: number;
    successRate?: number;      // Percentage
  };
}

/**
 * Individual coverage angle
 */
export interface CoverageAngle {
  id: string;

  // Classification
  category: 'rotational' | 'height' | 'distance' | 'specialty';
  type: string;               // e.g., "Medium", "Close Up", "Wide"
  angle: string;              // e.g., "Front", "3/4 Profile", "Low Angle"
  description: string;        // Human-readable description

  // Image data
  imageUrl: string;
  thumbnailUrl?: string;
  resolution: '1K' | '2K' | '4K';

  // Source tracking
  source: 'uploaded' | 'generated';

  // Generation metadata
  prompt?: string;            // Generation prompt used
  generatedAt?: Date;
  generationTime?: number;    // Time in seconds

  // Metadata
  metadata: {
    // Camera settings used
    focalLength?: string;
    aperture?: string;

    // Lighting info
    timeOfDay?: string;
    weather?: string;

    // Quality metrics
    aiScore?: number;         // 0-1

    // Cinematic purpose
    cinematicUse?: string[];  // e.g., ["establishing", "hero"]
  };

  // Usage tracking
  tags: string[];
  favorite: boolean;
  usedInStoryboard: boolean;
  usedInScenes: string[];     // Scene IDs

  // Status
  status: 'pending' | 'generating' | 'success' | 'failed';
  error?: string;

  createdAt: Date;
}

/**
 * Coverage generation request
 */
export interface CoverageGenerationRequest {
  entityId: string;
  entityType: EntityType;
  entity: CoverableEntity;  // The actual entity object

  packId: string;

  // Options
  options?: {
    resolution?: '1K' | '2K' | '4K';
    quality?: 'fast' | 'balanced' | 'quality';
    maxConcurrent?: number;    // Batch size (default: 5)
    retryFailed?: boolean;

    // Advanced controls
    timeOfDay?: string;
    weather?: string;
    lightingPreset?: string;
  };

  // Callbacks
  onProgress?: (progress: number, completed: number, total: number) => void;
  onAngleComplete?: (angle: CoverageAngle) => void;
  onComplete?: (library: CoverageLibrary) => void;
  onError?: (error: Error) => void;
}

/**
 * Batch generation status
 */
export interface BatchGenerationStatus {
  total: number;
  completed: number;
  failed: number;
  pending: number;
  progress: number;        // 0-100

  currentBatch: number;
  totalBatches: number;

  startedAt: number;
  estimatedCompletion?: number;

  angles: {
    angle: CoverageAngle;
    status: 'pending' | 'generating' | 'complete' | 'failed';
  }[];
}

/**
 * Coverage library filter
 */
export interface CoverageLibraryFilter {
  category?: 'rotational' | 'height' | 'distance' | 'specialty';
  source?: 'uploaded' | 'generated';
  favorite?: boolean;
  used?: boolean;
  tags?: string[];
}
